From 829422bdaad4a7b1f13b375adf96ea1fba35660b Mon Sep 17 00:00:00 2001
From: Dan Johansen <strit@manjaro.org>
Date: Sun, 5 Feb 2023 09:10:26 +0100
Subject: [PATCH 2/8] Revert "iopoll: Extend read_poll_timeout macro to support
 variable parameters"

This reverts commit d7db0e6df3e42a5d47bac4d3b7a9e6c13ac08ec9.
---
 arch/arm/mach-socfpga/reset_manager_s10.c | 20 +++++++++-----------
 drivers/mmc/rockchip_sdhci.c              |  9 ++++-----
 include/linux/iopoll.h                    | 12 ++++++------
 3 files changed, 19 insertions(+), 22 deletions(-)

diff --git a/arch/arm/mach-socfpga/reset_manager_s10.c b/arch/arm/mach-socfpga/reset_manager_s10.c
index f47fec10a0c6..d2337bd4d626 100644
--- a/arch/arm/mach-socfpga/reset_manager_s10.c
+++ b/arch/arm/mach-socfpga/reset_manager_s10.c
@@ -80,9 +80,9 @@ void socfpga_bridges_reset(int enable)
 			     ~0);
 
 		/* Poll until all idleack to 0 */
-		read_poll_timeout(readl, reg, !reg, 1000, 300000,
-				  socfpga_get_sysmgr_addr() +
-				  SYSMGR_SOC64_NOC_IDLEACK);
+		read_poll_timeout(readl, socfpga_get_sysmgr_addr() +
+				  SYSMGR_SOC64_NOC_IDLEACK, reg, !reg, 1000,
+				  300000);
 	} else {
 		/* set idle request to all bridges */
 		writel(~0,
@@ -93,20 +93,18 @@ void socfpga_bridges_reset(int enable)
 		writel(1, socfpga_get_sysmgr_addr() + SYSMGR_SOC64_NOC_TIMEOUT);
 
 		/* Poll until all idleack to 1 */
-		read_poll_timeout(readl, reg,
+		read_poll_timeout(readl, socfpga_get_sysmgr_addr() +
+				  SYSMGR_SOC64_NOC_IDLEACK, reg,
 				  reg == (SYSMGR_NOC_H2F_MSK |
 					  SYSMGR_NOC_LWH2F_MSK),
-				  1000, 300000,
-				  socfpga_get_sysmgr_addr() +
-				  SYSMGR_SOC64_NOC_IDLEACK);
+				  1000, 300000);
 
 		/* Poll until all idlestatus to 1 */
-		read_poll_timeout(readl, reg,
+		read_poll_timeout(readl, socfpga_get_sysmgr_addr() +
+				  SYSMGR_SOC64_NOC_IDLESTATUS, reg,
 				  reg == (SYSMGR_NOC_H2F_MSK |
 					  SYSMGR_NOC_LWH2F_MSK),
-				  1000, 300000,
-				  socfpga_get_sysmgr_addr() +
-				  SYSMGR_SOC64_NOC_IDLESTATUS);
+				  1000, 300000);
 
 		/* Reset all bridges (except NOR DDR scheduler & F2S) */
 		setbits_le32(socfpga_get_rstmgr_addr() + RSTMGR_SOC64_BRGMODRST,
diff --git a/drivers/mmc/rockchip_sdhci.c b/drivers/mmc/rockchip_sdhci.c
index 1fdc8415178b..f3f9d83ba36f 100644
--- a/drivers/mmc/rockchip_sdhci.c
+++ b/drivers/mmc/rockchip_sdhci.c
@@ -202,8 +202,8 @@ static void rk3399_emmc_phy_power_on(struct rockchip_emmc_phy *phy, u32 clock)
 	/* REN Enable on STRB Line for HS400 */
 	writel(RK_CLRSETBITS(0, 1 << 9), &phy->emmcphy_con[2]);
 
-	read_poll_timeout(readl, dllrdy, PHYCTRL_DLL_LOCK_WO_TMOUT(dllrdy), 1,
-			  5000, &phy->emmcphy_status);
+	read_poll_timeout(readl, &phy->emmcphy_status, dllrdy,
+			  PHYCTRL_DLL_LOCK_WO_TMOUT(dllrdy), 1, 5000);
 }
 
 static void rk3399_emmc_phy_power_off(struct rockchip_emmc_phy *phy)
@@ -328,9 +328,8 @@ static int rk3568_sdhci_emmc_set_clock(struct sdhci_host *host, unsigned int clo
 			DWCMSHC_EMMC_DLL_START;
 		sdhci_writel(host, extra, DWCMSHC_EMMC_DLL_CTRL);
 
-		ret = read_poll_timeout(readl, val, DLL_LOCK_WO_TMOUT(val), 1,
-					500,
-					host->ioaddr + DWCMSHC_EMMC_DLL_STATUS0);
+		ret = read_poll_timeout(readl, host->ioaddr + DWCMSHC_EMMC_DLL_STATUS0,
+					val, DLL_LOCK_WO_TMOUT(val), 1, 500);
 		if (ret)
 			return ret;
 
diff --git a/include/linux/iopoll.h b/include/linux/iopoll.h
index 0ee2bddaa833..30cdea0cdc16 100644
--- a/include/linux/iopoll.h
+++ b/include/linux/iopoll.h
@@ -14,11 +14,11 @@
 /**
  * read_poll_timeout - Periodically poll an address until a condition is met or a timeout occurs
  * @op: accessor function (takes @addr as its only argument)
+ * @addr: Address to poll
  * @val: Variable to read the value into
  * @cond: Break condition (usually involving @val)
  * @sleep_us: Maximum time to sleep in us
  * @timeout_us: Timeout in us, 0 means never timeout
- * @args: arguments for @op poll
  *
  * Returns 0 on success and -ETIMEDOUT upon a timeout. In either
  * case, the last read value at @addr is stored in @val.
@@ -26,15 +26,15 @@
  * When available, you'll probably want to use one of the specialized
  * macros defined below rather than this macro directly.
  */
-#define read_poll_timeout(op, val, cond, sleep_us, timeout_us, args...)	\
+#define read_poll_timeout(op, addr, val, cond, sleep_us, timeout_us)	\
 ({ \
 	unsigned long timeout = timer_get_us() + timeout_us; \
 	for (;;) { \
-		(val) = op(args); \
+		(val) = op(addr); \
 		if (cond) \
 			break; \
 		if (timeout_us && time_after(timer_get_us(), timeout)) { \
-			(val) = op(args); \
+			(val) = op(addr); \
 			break; \
 		} \
 		if (sleep_us) \
@@ -44,13 +44,13 @@
 })
 
 #define readx_poll_sleep_timeout(op, addr, val, cond, sleep_us, timeout_us) \
-	read_poll_timeout(op, val, cond, sleep_us, timeout_us, addr)
+	read_poll_timeout(op, addr, val, cond, sleep_us, timeout_us)
 
 #define readl_poll_sleep_timeout(addr, val, cond, sleep_us, timeout_us) \
 	readx_poll_sleep_timeout(readl, addr, val, cond, sleep_us, timeout_us)
 
 #define readx_poll_timeout(op, addr, val, cond, timeout_us) \
-	read_poll_timeout(op, val, cond, false, timeout_us, addr)
+	read_poll_timeout(op, addr, val, cond, false, timeout_us)
 
 #define readb_poll_timeout(addr, val, cond, timeout_us) \
 	readx_poll_timeout(readb, addr, val, cond, timeout_us)
-- 
2.39.1

